"""Stock feature generation including momentum indicators and volatility

    Currently RSI (Relative Strength Index), volatility, and price return rank are successfully calculated for each stock
    and for each day based on the basic price data ingested from yahoo. To Run the program,
    the stock_price_and_returns.csv file containing time series daily, monthly, and yearly returns
    must be generated by running the price_returns.py file and placed in the same directory.
    The output of the prgram will be an updated csv file with a new rsi and volatility column.

    TODO: percent off 52 week high, stock relative rank (based on price performance), and Sharp Ratio

George Krug
04/22/2019
"""


import pandas as pd
from talib import RSI
import matplotlib.pyplot as plt
import time
import math


START_DATE = '2011-01-03'
END_DATE = '2019-04-03'
ROLLING_WINDOW = 30
RANK_RECALCULATE = 1


def get_stock_rsi_daily(time_series_df, ticker):
    # compute RSI vector using ta-lib
    close = get_time_series_adjusted_close(time_series_df, ticker)
    rsi = RSI(close, timeperiod=20)
    rsi_series = pd.Series(rsi)
    # add to db data structure
    tmpDf = pd.DataFrame(data=rsi_series, columns=['RSI'])
    time_series_df.loc[ticker, 'RSI'] = tmpDf['RSI'].values
    return time_series_df


def get_stock_percent_off_52_week_high():
    pass


def add_return_rank(df, ticker_list, date_list):

    new_df = df
    new_df["Return_Rank"] = -1
    print(new_df.head(500))
    for date in date_list:
        for symbol in ticker_list:
            try:
                if not math.isnan(df.loc[symbol, date].loc['Pct_Change_Yearly']):
                    pass
            except Exception as err:
                pass


def get_stock_trailing_52_week_performance_rank(df, ticker_list, date_list):
    rank_df = pd.DataFrame()
    counter = -1
    global new_df
    global start_date
    global copyDf
    start_date = '2011-01-03'
    nan = False
    new_df = pd.DataFrame()

    copyDf = df.copy()
    copyDf['Return_Rank'] = -1

    for date in date_list:
        ser = {}
        emp = {}
        counter = counter + 1
        for symbol in ticker_list:
            try:
                if not math.isnan(df.loc[symbol, date].loc['Pct_Change_Yearly']):
                    ser[symbol] = df.loc[symbol, date].loc['Pct_Change_Yearly']
                else:
                    emp[symbol] = 'x'
                    continue
            except Exception as err:
                continue
        if len(ser) > 0:
            df_tmp = df.reset_index(level=0)
            ser_df = pd.DataFrame.from_dict(ser, orient='index', columns=['Return'])
            ser_df.sort_values(by=['Return'], ascending=False, inplace=True)
            ser_df.reset_index(level=0, inplace=True)
            ser_df['Return_Rank'] = ser_df.index
            ser_df.columns = ['Symbol', 'Return', 'Return_Rank']
            new_df = pd.DataFrame()
            new_df = pd.merge(df_tmp.loc[date], ser_df, on='Symbol', how='left')
            new_df['Date'] = date
            new_df.set_index(['Symbol', 'Date'], inplace=True)
            rank_df = rank_df.append(new_df)
        else:
            df_tmp = df.reset_index(level=0)
            ser_df = pd.DataFrame.from_dict(emp, orient='index', columns=['Return'])
            ser_df.reset_index(level=0, inplace=True)
            ser_df['Return_Rank'] = 0
            ser_df.columns = ['Symbol', 'Return', 'Return_Rank']
            new_df = pd.DataFrame()
            new_df = pd.merge(df_tmp.loc[date], ser_df, on='Symbol', how='left')
            new_df['Date'] = date
            new_df.set_index(['Symbol', 'Date'], inplace=True)
            rank_df = rank_df.append(new_df)

    return rank_df


def get_stock_volatility(time_series_df, ticker):
    close = get_time_series_adjusted_close(time_series_df, ticker)
    # compute Volatility with intermediate-term rolling window
    close_series = pd.Series(close)
    roller = close_series.rolling(ROLLING_WINDOW)
    vol_vec = roller.std(ddof=0)
    tmp_vol_df = pd.DataFrame(data=vol_vec, columns=['Volatility'])
    time_series_df.loc[ticker, 'Volatility'] = (tmp_vol_df['Volatility'].values / close) * 12
    return time_series_df


def get_stock_sharp_ratio():
    pass


def get_time_series_adjusted_close(time_series_df, ticker):
    return time_series_df.loc[ticker].loc[::, 'AdjClose'].values


def get_dataframe_from_csv(file):
    try:
        df = pd.read_csv(file)
    except FileNotFoundError as err:
        print("FileNotFoundError with path " + file + "\nError: " + err)
        raise
    return df


def add_columns_to_df(basic_df, columns):
    # Set Multi Index on the dataframe to get the 3d data structure
    try:
        new_df = basic_df.set_index(['Symbol', 'Date'])
    except Exception as err:
        print("index set error")
        print(err)
        raise

    # Add columns to the new df
    for col in columns:
        new_df[col] = -1

    return new_df


def main():

    print('Generating Momentum Features\n-------------------------------------------------------------')
    file_path = "stock_prices_and_returns.csv"
    output_file_path = "momentum-features.csv"
    test_output_file = "test-momentum.csv"
    new_columns = ['RSI', 'Volatility']
    ticker_list = []
    date_list = []

    basic_df = get_dataframe_from_csv(file_path)
    df = add_columns_to_df(basic_df, new_columns)

    print('Updating Dataframe with RSI, Volatility, and Performance Rank columns......')
    start = time.time()
    for symbol, mrow in df.groupby(level=0):
        df = get_stock_rsi_daily(df, symbol)
        df = get_stock_volatility(df, symbol)

    for symbol, mrow in df.groupby(level=0):
        ticker_list.append(symbol)

    for date, mrow in df.groupby(level=1):
        date_list.append(date)

    df = get_stock_trailing_52_week_performance_rank(df, ticker_list, date_list)
    df.reset_index(level=0, inplace=True)
    print("Writing to file: " + output_file_path)
    df.to_csv(output_file_path, encoding='utf-8', index=True)
    end = time.time()
    print("Process time: " + str(end - start) + " seconds.")


if __name__ == '__main__':
    main()
